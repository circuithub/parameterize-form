/*
 * Copyright 2013, CircuitHub.com
 */
var parameterize = parameterize || {}; /* Redeclaring parameterize is fine: behaves like a no-op (https://developer.mozilla.org/en/JavaScript/Reference/Scope_Cheatsheet) */
(function(){
var originalRequire = this.require || (void 0);


(function(/*! Stitch !*/) {
  if (!this.require) {
    var modules = {}, cache = {}, require = function(name, root) {
      var path = expand(root, name), module = cache[path], fn;
      if (module) {
        return module.exports;
      } else if (fn = modules[path] || modules[path = expand(path, './index')]) {
        module = {id: path, exports: {}};
        try {
          cache[path] = module;
          fn(module.exports, function(name) {
            return require(name, dirname(path));
          }, module);
          return module.exports;
        } catch (err) {
          delete cache[path];
          throw err;
        }
      } else {
        throw 'module \'' + name + '\' not found';
      }
    }, expand = function(root, name) {
      var results = [], parts, part;
      if (/^\.\.?(\/|$)/.test(name)) {
        parts = [root, name].join('/').split('/');
      } else {
        parts = name.split('/');
      }
      for (var i = 0, length = parts.length; i < length; i++) {
        part = parts[i];
        if (part == '..') {
          results.pop();
        } else if (part != '.' && part != '') {
          results.push(part);
        }
      }
      return results.join('/');
    }, dirname = function(path) {
      return path.split('/').slice(0, -1).join('/');
    };
    this.require = function(name) {
      return require(name, '');
    }
    this.require.define = function(bundle) {
      for (var key in bundle) {
        modules[key] = bundle[key];
        var ext = key.split('.').pop();
        if (ext.indexOf('/') === -1 && ext.length < key.length)
          modules[key.slice(0,-ext.length - 1)] = bundle[key];
      }
    };
  }
  return this.require.define;
}).call(this)({"html.js": function(exports, require, module) {// Generated by CoffeeScript 1.4.0
var __slice = [].slice;

(function(adt, html) {
  var escapeAttrib, groupByTolerance, labeledCompositeTolerance, labeledElements, labeledInput, labeledInputs, labeledTolerance, resolveMeta, shortLabelLength, toleranceHTML, wrap, wrapComposite;
  shortLabelLength = 5;
  escapeAttrib = function(str) {
    return (String(str)).replace(/['"]/gi, "`");
  };
  groupByTolerance = function(as) {
    var a, gs, _i, _len, _ref, _ref1;
    gs = [];
    for (_i = 0, _len = as.length; _i < _len; _i++) {
      a = as[_i];
      if (a._tag === 'tolerance' && ((_ref = gs[gs.length - 1]) != null ? _ref._tag : void 0) === 'tolerance') {
        (_ref1 = gs[gs.length - 1]).push.apply(_ref1, a);
      } else {
        gs.push(a);
      }
    }
    return gs;
  };
  wrap = function() {
    return html.div.apply(html, [{
      "class": "parameter"
    }].concat(__slice.call(arguments)));
  };
  wrapComposite = function() {
    var args, classes, description;
    classes = arguments[0], description = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
    return html.div.apply(html, [{
      "class": "parameter param-composite " + classes,
      title: escapeAttrib(description)
    }].concat(__slice.call(args)));
  };
  labeledElements = function() {
    var elements, label;
    label = arguments[0], elements = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    return html.label.apply(html, [{
      "class": "param-label"
    }, html.span({
      "class": "param-label-text"
    }, String(label))].concat(__slice.call(elements)));
  };
  labeledInput = function(label, value) {
    return labeledElements(label, html.input({
      "class": "param-input",
      value: String(value)
    }));
  };
  labeledInputs = function(n, labels, values, shortLabels) {
    var i, _i, _results;
    if (shortLabels == null) {
      shortLabels = false;
    }
    if (!shortLabels) {
      _results = [];
      for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
        _results.push(labeledInput(labels[i], values[i]));
      }
      return _results;
    } else {
      return [
        html.table({
          "class": "param-composite-table"
        }, html.thead({
          "class": "param-composite-thead"
        }, html.tr.apply(html, [{
          "class": "param-composite-thead-tr"
        }].concat(__slice.call((function() {
          var _j, _results1;
          _results1 = [];
          for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
            _results1.push(html.th({
              "class": "param-composite-th"
            }, labeledElements(labels[i])));
          }
          return _results1;
        })())))), html.tbody({
          "class": "param-composite-tbody"
        }, html.tr.apply(html, [{
          "class": "param-composite-tr"
        }].concat(__slice.call((function() {
          var _j, _results1;
          _results1 = [];
          for (i = _j = 0; 0 <= n ? _j < n : _j > n; i = 0 <= n ? ++_j : --_j) {
            _results1.push(html.td({
              "class": "param-composite-td"
            }, html.input({
              "class": "param-input",
              value: String(values[i])
            })));
          }
          return _results1;
        })())))))
      ];
    }
  };
  labeledTolerance = function(label, tolerance) {
    return [
      html.th({
        "class": "param-tolerance-th",
        scope: "row"
      }, html.label({
        "class": "param-label"
      }, label)), html.td(html.input({
        "class": "param-input",
        value: String(tolerance.min)
      })), html.td(html.input({
        "class": "param-input",
        value: String(tolerance.max)
      }))
    ];
  };
  labeledCompositeTolerance = function(n, labels, tolerances) {
    var i, _i, _results;
    _results = [];
    for (i = _i = 0; 0 <= n ? _i < n : _i > n; i = 0 <= n ? ++_i : --_i) {
      _results.push(labeledTolerance(labels[i], {
        min: tolerances.min[i],
        max: tolerances.max[i]
      }));
    }
    return _results;
  };
  toleranceHTML = adt({
    real: function(id, meta, defaultTolerance) {
      var _ref;
      if (typeof meta === 'string') {
        meta = {
          label: meta
        };
      } else if (!(meta != null)) {
        meta = {
          label: id
        };
      } else if (!(meta.label != null)) {
        meta.label = id;
      }
      if ((_ref = meta.description) == null) {
        meta.description = "";
      }
      return html.tr.apply(html, [{
        "class": "parameter param-numeric param-real",
        title: escapeAttrib(meta.description)
      }].concat(__slice.call(labeledTolerance(meta.label, defaultTolerance))));
    },
    dimension1: function(id, meta, defaultTolerance) {
      var _ref;
      if (typeof meta === 'string') {
        meta = {
          label: meta
        };
      } else if (!(meta != null)) {
        meta = {
          label: id
        };
      } else if (!(meta.label != null)) {
        meta.label = id;
      }
      if ((_ref = meta.description) == null) {
        meta.description = "";
      }
      return html.tr.apply(html, [{
        "class": "parameter param-numeric param-dimension1",
        title: escapeAttrib(meta.description)
      }].concat(__slice.call(labeledTolerance(meta.label, defaultTolerance))));
    },
    dimension2: function(id, meta, defaultTolerance) {
      var tds, trs, _ref, _ref1;
      if (typeof meta === 'string') {
        meta = {
          label: meta
        };
      } else if (!(meta != null)) {
        meta = {};
      }
      if ((_ref = meta.description) == null) {
        meta.description = "";
      }
      if ((_ref1 = meta.components) == null) {
        meta.components = ["X", "Y"];
      }
      if (!Array.isArray(defaultTolerance.min)) {
        defaultTolerance.min = [defaultTolerance.min, defaultTolerance.min, defaultTolerance.min];
      }
      if (!Array.isArray(defaultTolerance.max)) {
        defaultTolerance.max = [defaultTolerance.max, defaultTolerance.max, defaultTolerance.max];
      }
      trs = !(meta.label != null) ? [] : [
        html.tr(html.th({
          "class": "",
          colspan: 3,
          scope: "rowgroup"
        }, escapeAttrib(meta.label)))
      ];
      trs = trs.concat((function() {
        var _i, _len, _ref2, _results;
        _ref2 = labeledCompositeTolerance(2, meta.components, defaultTolerance);
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          tds = _ref2[_i];
          _results.push(html.tr.apply(html, [{
            "class": "param-numeric"
          }].concat(__slice.call(tds))));
        }
        return _results;
      })());
      return html.tbody.apply(html, [{
        "class": "parameter param-composite param-dimension2",
        title: escapeAttrib(meta.description)
      }].concat(__slice.call(trs)));
    },
    dimension3: function(id, meta, defaultTolerance) {
      var tds, trs, _ref, _ref1;
      if (typeof meta === 'string') {
        meta = {
          label: meta
        };
      } else if (!(meta != null)) {
        meta = {
          label: id
        };
      } else if (!(meta.label != null)) {
        meta.label = id;
      }
      if ((_ref = meta.description) == null) {
        meta.description = "";
      }
      if ((_ref1 = meta.components) == null) {
        meta.components = ["X", "Y", "Z"];
      }
      if (!Array.isArray(defaultTolerance.min)) {
        defaultTolerance.min = [defaultTolerance.min, defaultTolerance.min, defaultTolerance.min];
      }
      if (!Array.isArray(defaultTolerance.max)) {
        defaultTolerance.max = [defaultTolerance.max, defaultTolerance.max, defaultTolerance.max];
      }
      trs = !(meta.label != null) ? [] : [
        html.tr(html.th({
          "class": "",
          colspan: 3,
          scope: "rowgroup"
        }, escapeAttrib(meta.label)))
      ];
      trs = trs.concat((function() {
        var _i, _len, _ref2, _results;
        _ref2 = labeledCompositeTolerance(3, meta.components, defaultTolerance);
        _results = [];
        for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
          tds = _ref2[_i];
          _results.push(html.tr.apply(html, [{
            "class": "param-numeric"
          }].concat(__slice.call(tds))));
        }
        return _results;
      })());
      return html.tbody.apply(html, [{
        "class": "parameter param-composite param-dimension3",
        title: escapeAttrib(meta.description)
      }].concat(__slice.call(trs)));
    },
    vector2: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    vector3: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    point2: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    point3: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    pitch1: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    pitch2: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    pitch3: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    angle: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    polar: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    cylindrical: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    spherical: function() {
      throw "Unsupported tolerance type `" + this._tag + "` (TODO)";
    },
    _: function() {
      throw "Unsupported tolerance type `" + this._tag + "`";
    }
  });
  resolveMeta = function(id, meta) {
    var _ref, _ref1;
    if (typeof meta === 'string') {
      meta = {
        label: meta
      };
    } else if (!(meta != null)) {
      meta = {
        label: id
      };
    } else {
      if ((_ref = meta.label) == null) {
        meta.label = id;
      }
    }
    if ((_ref1 = meta.description) == null) {
      meta.description = "";
    }
    return meta;
  };
  return module.exports = adt({
    parameters: function() {
      var children, description;
      description = arguments[0], children = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return html.div.apply(html, [{
        "class": "parameters"
      }].concat(__slice.call(adt.map(this, children))));
    },
    section: function() {
      var children, heading;
      heading = arguments[0], children = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return html.section.apply(html, [{
        "class": "param-section"
      }, html.h1({
        "class": "param-heading"
      }, String(heading))].concat(__slice.call(adt.map(this, groupByTolerance(children)))));
    },
    real: function(id, meta, defaultValue) {
      meta = resolveMeta(id, meta);
      return wrap(html.div({
        "class": "param-numeric param-real",
        title: escapeAttrib(meta.description)
      }, html.label({
        "class": "param-label"
      }, html.span({
        "class": "param-label-text"
      }, String(meta.label)), html.input({
        "class": "param-input",
        value: String(defaultValue)
      }))));
    },
    dimension1: function(id, meta, defaultValue) {
      meta = resolveMeta(id, meta);
      return wrap(html.div({
        "class": "param-numeric param-dimension1",
        title: escapeAttrib(meta.description)
      }, html.label({
        "class": "param-label"
      }, html.span({
        "class": "param-label-text"
      }, String(meta.label)), html.input({
        "class": "param-input",
        value: String(defaultValue)
      }))));
    },
    dimension2: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, ["param-numeric param-dimension2", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(2, meta.components, defaultValue, shortLabels))));
    },
    dimension3: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y", "Z"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length, meta.components[2].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, ["param-numeric param-dimension3", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(3, meta.components, defaultValue, shortLabels))));
    },
    vector2: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, ["param-numeric param-vector2", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(2, meta.components, defaultValue, shortLabels))));
    },
    vector3: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y", "Z"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length, meta.components[2].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, ["param-numeric param-vector3", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(3, meta.components, defaultValue, shortLabels))));
    },
    point2: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, ["param-numeric param-point2", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(2, meta.components, defaultValue, shortLabels))));
    },
    point3: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y", "Z"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length, meta.components[2].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, ["param-numeric param-point3", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(3, meta.components, defaultValue, shortLabels))));
    },
    pitch1: function(id, meta, defaultValue) {
      meta = resolveMeta(id, meta);
      return wrap(html.div({
        "class": "param-numeric param-pitch1",
        title: escapeAttrib(meta.description)
      }, html.label({
        "class": "param-label"
      }, html.span({
        "class": "param-label-text"
      }, String(meta.label)), html.input({
        "class": "param-input",
        value: String(defaultValue)
      }))));
    },
    pitch2: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, ["param-numeric param-pitch2", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(2, meta.components, defaultValue, shortLabels))));
    },
    pitch3: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y", "Z"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length, meta.components[2].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, ["param-numeric param-pitch3", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(3, meta.components, defaultValue, shortLabels))));
    },
    angle: function(id, meta, defaultValue) {
      throw "Unsupported parameter type `" + this._tag + "` (TODO)";
    },
    polar: function(id, meta, defaultValue) {
      throw "Unsupported parameter type `" + this._tag + "` (TODO)";
    },
    cylindrical: function(id, meta, defaultValue) {
      throw "Unsupported parameter type `" + this._tag + "` (TODO)";
    },
    spherical: function(id, meta, defaultValue) {
      throw "Unsupported parameter type `" + this._tag + "` (TODO)";
    },
    integer: function(id, meta, defaultValue) {
      throw "Unsupported parameter type `" + this._tag + "` (TODO)";
    },
    natural: function(id, meta, defaultValue) {
      throw "Unsupported parameter type `" + this._tag + "` (TODO)";
    },
    latice1: function(id, meta, defaultValue) {
      meta = resolveMeta(id, meta);
      return wrap(html.div({
        "class": "param-numeric param-latice1",
        title: escapeAttrib(meta.description)
      }, html.label({
        "class": "param-label"
      }, html.span({
        "class": "param-label-text"
      }, String(meta.label)), html.input({
        "class": "param-input",
        value: String(defaultValue)
      }))));
    },
    latice2: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, ["param-numeric param-latice2", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(2, meta.components, defaultValue, shortLabels))));
    },
    latice3: function(id, meta, defaultValue) {
      var shortLabels, _ref;
      meta = resolveMeta(id, meta);
      if ((_ref = meta.components) == null) {
        meta.components = ["X", "Y", "Z"];
      }
      shortLabels = Math.max(meta.components[0].length, meta.components[1].length, meta.components[2].length) < shortLabelLength;
      if (!Array.isArray(defaultValue)) {
        defaultValue = [defaultValue, defaultValue, defaultValue];
      }
      return wrapComposite.apply(null, ["param-numeric param-latice3", meta.description, html.label({
        "class": "param-composite-label"
      }, html.span({
        "class": "param-label-text"
      }, String(meta.label)))].concat(__slice.call(labeledInputs(3, meta.components, defaultValue, shortLabels))));
    },
    option: function(id, meta, options, defaultOption) {
      var k, keyValue, v, _ref;
      if (typeof meta === 'string') {
        meta = {
          label: meta
        };
      } else if (!(meta != null)) {
        meta = {
          label: id
        };
      } else if (!(meta.label != null)) {
        meta.label = id;
      }
      if ((_ref = meta.description) == null) {
        meta.description = "";
      }
      keyValue = {};
      options = (function() {
        var _i, _len, _results;
        if (Array.isArray(options)) {
          _results = [];
          for (_i = 0, _len = options.length; _i < _len; _i++) {
            k = options[_i];
            _results.push(keyValue[k] = k);
          }
          return _results;
        } else {
          return keyValue = options;
        }
      })();
      if (defaultOption == null) {
        defaultOption = (Object.keys(keyValue))[0];
      }
      return wrap(html.div({
        "class": "param-numeric param-real",
        title: escapeAttrib(meta.description)
      }, labeledElements(meta.label, html.select.apply(html, [{
        "class": "param-select"
      }].concat(__slice.call((function() {
        var _results;
        _results = [];
        for (k in keyValue) {
          v = keyValue[k];
          _results.push(html.option({
            value: k,
            selected: (k === defaultOption ? true : void 0)
          }, v));
        }
        return _results;
      })()))))));
    },
    boolean: function(id, meta, defaultValue) {
      var _ref;
      if (typeof meta === 'string') {
        meta = {
          label: meta
        };
      } else if (!(meta != null)) {
        meta = {
          label: id
        };
      } else if (!(meta.label != null)) {
        meta.label = id;
      }
      if ((_ref = meta.description) == null) {
        meta.description = "";
      }
      return wrap(html.div({
        "class": "param-boolean",
        title: escapeAttrib(meta.description)
      }, labeledElements(meta.label, html.input({
        type: "checkbox",
        "class": "param-checkbox"
      }))));
    },
    tolerance: function() {
      var i, ii, rowgroup, rowgroups, tbodies, tolerances, _i, _len;
      tolerances = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (tolerances.length === 0) {
        return;
      }
      rowgroups = adt.map(toleranceHTML, tolerances);
      tbodies = [];
      ii = NaN;
      for (i = _i = 0, _len = rowgroups.length; _i < _len; i = ++_i) {
        rowgroup = rowgroups[i];
        if (rowgroup._tag === "tr") {
          if (ii === i - 1) {
            tbodies[tbodies.length - 1].push(rowgroup);
          } else {
            tbodies.push(html.tbody({
              "class": ""
            }, rowgroup));
          }
          ii = i;
        } else {
          tbodies.push(rowgroup);
        }
      }
      return html.table.apply(html, [{
        "class": "param-tolerance-table"
      }, html.thead({
        "class": "param-tolerance-thead"
      }, html.tr({
        "class": "param-tolerance-legend"
      }, html.th({
        "class": "param-tolerance-th"
      }), html.th({
        "class": "param-tolerance-th"
      }, "Min"), html.th({
        "class": "param-tolerance-th"
      }, "Max")))].concat(__slice.call(tbodies)));
    },
    range: function(id, meta, defaultValue, range) {
      throw "Unsupported parameter type `" + this._tag + "` (TODO)";
    },
    _: function() {
      throw "Unsupported parameter type `" + this._tag + "`";
    }
  });
})(typeof adt !== "undefined" && adt !== null ? adt : require('adt.js'), typeof html !== "undefined" && html !== null ? html : require('adt-html.js'));
}, "parameterize-form.js": function(exports, require, module) {// Generated by CoffeeScript 1.4.0

(function(adt) {
  var form;
  form = {
    html: require("html")
  };
  form.form = adt.constructors(form.html);
  form.get = function(formElement) {};
  form.set = function(formElement, form) {};
  form.on = function(eventKey, callback) {};
  return module.exports = form;
})(typeof adt !== "undefined" && adt !== null ? adt : require('adt.js'));
}, "adt-html.js": function(exports, require, module) {/*
 * adt-html.js - Algebraic Data Types for JavaScript
 * adt-html.js is free, public domain software (http://creativecommons.org/publicdomain/zero/1.0/)
 * Originally created by Rehno Lindeque of http://www.mischievousmeerkat.com
 * Use it in combination with https://github.com/rehno-lindeque/adt.js
 */
var adt = adt || (typeof require === 'function'? require('adt.js') : {}), 
html = (function() {
"use strict";
  // Using the html5 list of tags from (http://joshduck.com/periodic-table.html)
  // Other html api's should probably be in separate libraries? (xhtml, html4 etc)
  var
    _cons = adt(
      // Root element
      'html', 
      // Metadata and scripting
      'head','title','meta','base','link','style','noscript','script',
      // Text-level semantics
      'span','a','rt','rp','dfn','abbr','q','cite','em','time','var','samp','i',
      'b','sub','sup','small','strong','mark','ruby','ins','del','bdi','bdo',
      's','kbd','wbr','code',
      // Grouping content
      'br','hr','figcaption','figure','p','ol','ul','li','div','pre',
      'blockquote','dl','dt','dd',
      // Forms
      'fieldset','meter','legend','label','input','textarea','form','select',
      'optgroup','option','output','button','datalist','keygen','progress',
      // Document sections
      'body','aside','address','h1','h2','h3','h4','h5','h6','section','header',
      'nav','article','footer','hgroup',
      // Tabular data
      'col','colgroup','caption','table','tr','td','th','tbody','thead','tfoot',
      // Interactive elements
      'menu','command','summary','details',
      // Embedding content
      'img','area','map','embed','object','param','source','iframe','canvas',
      'track','audio','video'
    ),
    _eval = adt({ _: function(attributes) {
        var el = document.createElement(this._tag);
        for (var i = 0; i < arguments.length; ++i)
          // Check if the argument is a DOM node
          if (arguments[i].nodeType)
            el.appendChild(arguments[i]);
          else if (typeof arguments[i] === 'string')
            el.appendChild(document.createTextNode(arguments[i]));
        if (typeof attributes === 'object' && typeof attributes.nodeType === 'undefined') {
          for (var key in attributes)
            el.setAttribute(key, attributes[key]);
        }
        return el;
      }
    }),
    html = (typeof adt.compose === 'undefined')?
      function(){ throw "`adt.compose()` is needed in order to use html as a function."; }
      : adt.compose(_eval, _cons);
    html.cons = _cons;
    html.eval = _eval;
  // Export html to a CommonJS module if exports is available
  if (typeof module !== "undefined" && module !== null)
    module.exports = html;
  return html;
})();
}, "adt.js": function(exports, require, module) {/*
 * adt.js - Algebraic Data Types for JavaScript
 * adt.js is free, public domain software (http://creativecommons.org/publicdomain/zero/1.0/)
 * Originally created by Rehno Lindeque of http://www.mischievousmeerkat.com
 */
var adt = (function() {
"use strict";
  // Define a local copy of adt
  var
    isADT = function(data) {
      return Array.isArray(data) && typeof data['_tag'] === 'string';
    },
    isInterface = function(obj) {
      return typeof obj === 'function' && typeof obj['_eval'] === 'function';
    },
    init = function(selfProto, args) {
      var i, key, strA;
      for (i = 0; i < args.length; ++i) {
        var a = args[i];
        if (Array.isArray(a))
          init(selfProto, a);
        else if (typeof a === 'string' || typeof a === 'number') {
          if (a !== '_' && String(a).charAt(0) === '_')
            continue; // ignore constructors for private members starting with _
          else
            selfProto[a] = (function(tag) { return function() { return construct(tag, arguments); }; })(a);
        }
        else if (typeof a === 'object' || typeof a === 'function') {
          for (key in a)
            if (key !== '_' && key.charAt(0) === '_')
              continue; // ignore evaluators for private members starting with _
            else if (typeof(a[key]) === 'function')
              selfProto[key] = a[key];
            else
              selfProto[key] = (function(val){ return function() { return val; }; })(a[key]);
        }
        else
          continue; // TODO: WARNING: unidentified argument passed to adt
      }
    },
    adt = function() {
      // Arguments to this function can be either constructor names (strings or 
      // arrays of strings, numbers or arrays of numbers) or evaluators (dispatch tables or arrays of dispatch
      // tables with keys as deconstructors and values as dispatch functions)
      var selfProto = {};
      init(selfProto, arguments);
      return evaluators(selfProto);
    },
    // Get the internal [[Class]] property (or `Undefined` or `Null` for `(void 0)` and `null` respectively)
    getObjectType = function(data) {
      var str = Object.prototype.toString.call(data);
      return str.slice(str.indexOf(' ') + 1, str.length - 1);
    },
    getDataType = function(data) {
      if (isADT(data)) return 'ADT'; else return getObjectType(data);
    },
    getTypeTag = function(data) {
      if (isADT(data)) return data._tag; else return getObjectType(data);
    };
  adt.isADT = isADT;
  adt.isInterface = isInterface;
  adt.version = "3.0.0";  var construct = function(tag, args) {
    // Make a shallow copy of args and patch on the tag
    var data = [].slice.call(args, 0);
    data._tag = tag;
    return data;
  };
  /* TODO: Possibly expose it in the future...
  adt.construct = function(tag) {
    if (arguments.length < 1)
      throw "Incorrect number of arguments passed to `construct()`."
    return construct(tag, [].slice.call(arguments, 1));
  };*/

  // ADT evaluators common
  // ADT evaluators API (version 3)
  var 
    evaluators = function(selfProto) {
      var 
        tag,
        evaluators = function(){
          // TODO: Add a second private method called `_run` which includes composition/recursion etc as applied by external plugins.
          //       This would hopefully allow people to write generic higher-order functions that work together seamlesly.
          return evaluators._eval.apply(evaluators, arguments);
        };

      // Create an identity constructor for the fall through pattern if none was supplied
      if (typeof selfProto['_'] === 'undefined') {
        selfProto['_'] = function(){
          return this._datatype !== 'ADT'? arguments[0] : construct(this._tag, arguments);
        },
        evaluators['_'] = function(){ return selfProto['_'].apply(evaluators, arguments); };
      }
        
      // Add adt constructors / methods to the evaluators
      for (tag in selfProto)
        switch(tag) {
          case 'eval':
            continue;  // Warning? trying to overide standard functions
          default:
            if (tag !== 'eval') {
              if (typeof selfProto[tag] === 'function')
                // Custom evaluators
                evaluators[tag] = (function(tag){ return function(){ return selfProto[tag].apply(evaluators, arguments); }; })(tag);
              else 
                // Constant constructor (return the constant value)
                evaluators[tag] = (function(tag){ return function(){ return selfProto[tag]; }; })(tag);
            }
        }

      /* METHOD 1 (FAST DISPATCH - TODO) Generate pattern matcher + dispatch function
      var 
        patternMatcher = "\"use strict\";\n",
        merge = function(dict,k,v) { return dict[k] ? dict[k].push(v) : [v]; },
        tuples = {},
        variableTuples = false, // (Are there variable length tuples in the pattern?)
        prevLength = null,
        tuple,
        i,
        generateTupleMatcher = function(){
        };
      for (tag in evaluators)
        switch(tag) {
          case '_eval': continue;
          default: 
            tuple = tag.split(',');
            merge(tuples, tuple.length, tuple);
            variableTuples = (prevLength !== null && prevLength !== tuple.length);
            prevLength = tuple.length;
        }
      if (variableTuples)
        patternMatcher.concat("switch(arguments.length){\n")
      for (i in tuples) {
        if (variableTuples)
          patternMatcher.concat("case " + i + ":\n");
        patternMatcher.concat(generateTupleMatcher(tuples[i]));        
      }
      if (variableTuples)
        patternMatcher.concat(
          "default:\n"
          + "return false;\n"
          + "}\n")
      //*/

      //* METHOD 2 (FAST COMPILATION)
      // Tokenize patterns into (length, (pattern,tuple))
      var 
        appendAt = function(dict,k,v) { 
          if (dict[k]) dict[k].push(v); else dict[k] = [v]; 
        },
        pattern,
        patternTuples = {};
      for (pattern in evaluators)
        switch(pattern) {
          case '_eval': continue;
          default: 
            var tuple = pattern.split(',').map(function(s) { 
              return s.split(' ').filter(function(s) { return s !== ''; }); 
            });
            appendAt(patternTuples, tuple.length, [pattern, tuple]);
        }

      // Order patternTuples in order from most specific to most general (order of patterns in evaluators cannot be relied upon)
      (function(){
        var l, pt;
        for (l in patternTuples) {
          pt = patternTuples[l];
          pt.sort(function(a,b) {
            // Pre-condition: a[1].length == b[1].length (patternTuples are already grouped by length)
            var i,j;
            for (i = 0; i < a[1].length; ++i) {
              // Calculate relative generality of the two patterns
              // 1. The most specific constructor is always the one with the largest number of arguments specified, even if they are wildcards...
              //    I.e. The most general constructor is always the one with the fewest arguments specified...
              if (a[1][i].length !== b[1][i].length)
                return a[1][i].length > b[1][i].length? -1 : 1;
              // 2. Wild card patterns > ADT > Everything else
              for (j = 0; j < a[1][i].length; ++j) {
                if (a[1][i][j] !== '_' && b[1][i][j] === '_')
                  return -1; // a less general than b
                if (a[1][i][j] === '_' && b[1][i][j] !== '_')
                  return 1; // a more general than b
                if (a[1][i][j] !== 'ADT' && b[1][i][j] === 'ADT')
                  return -1; // a less general than b
                if (a[1][i][j] === 'ADT' && b[1][i][j] !== 'ADT')
                  return 1; // a more general than b
              }
            }
            // 3. For the remainder, simply sort patterns alphabetically
            return a[0] < b[0]? -1 : 1;
          });
        }
      })();

      var 
        matchShallow = function(tag, datum) {
          return tag === getTypeTag(datum) || tag == '_' || (isADT(datum) && tag == 'ADT');
        },
        matchCons = function(consPattern, datum) {
          // Pre-condition: consPattern.length > 0
          // The function returns a list of unboxed arguments to send to the evaluator
          var i;
          if (isADT(datum)) {
            if (consPattern[0] == '_')
              return datum.slice(0);
            if (consPattern[0] !== datum._tag)
              return null;
            if (consPattern.length === 1)
              return datum.slice(0);
            for (i = 0; i < datum.length; ++i)
              if (!matchShallow(consPattern[i + 1], datum[i]))
                return null;
            return datum.slice(0);
          }
          else if (consPattern.length === 1 
              && (consPattern[0] === getObjectType(datum) || consPattern[0] === '_'))
            return [datum];
          return null;
        },
        matchTuple = function(tuplePattern, args) {
          // Pre-condition: tuplePattern.length == args.length
          var 
            i,
            d,
            data = [];
          for (i = 0; i < tuplePattern.length; ++i) {
            d = matchCons(tuplePattern[i], args[i]);
            if (d == null)
              return null;
            data = data.concat(d);
          }
          return {
            data: data,
            pattern: tuplePattern.map(function(s){ return s.join(' ') }).join(','),
            datatype: Array.prototype.map.call(args, getDataType).join(','),
            tag: Array.prototype.map.call(args, getTypeTag).join(','),
          };
        },
        matcherFunc = function() {
          var i, m, pt = patternTuples[arguments.length];
          if (pt != null)
            for (i = 0; i < pt.length; ++i) {
              m = matchTuple(pt[i][1], arguments);
              if (m != null) {
                m.eval = evaluators[pt[i][0]];
                // TODO: m.exactPattern = pt[i][0];
                return m;
              }
            }
          return null;
        };
      //*/

      evaluators._eval = function() {
        // Determine if the data is a construction (built by a constructor)
        var i,
          tags = [],
          dataTypes = [];
        
        var m = matcherFunc.apply((void 0), arguments);
        if (m == null) {
          evaluators._pattern = '_';
          evaluators._tag = Array.prototype.map.call(arguments, getTypeTag).join(',');
          evaluators._datatype = Array.prototype.map.call(arguments, getDataType).join(',');
          var data = Array.prototype.reduce.call(arguments, function(a,b){ return a.concat(isADT(b)? b : [b]); }, []);
          return evaluators._.apply(evaluators, data);
        }
        evaluators._pattern = m.pattern;
        evaluators._tag = m.tag;
        evaluators._datatype = m.datatype;
        return m.eval.apply(evaluators, m.data);
      };
      return evaluators;
    };
  // Automatically create constructors for any dispatch table
  adt.constructors = function(obj) {
    var key, keys = [];
    if (obj != null)
      for (key in obj)
        keys.push(key);
    return adt.apply(null, keys);
  };

  var applyWith = function(f){ return function(a){ return f(a) }; };
  adt.map = function(fadt, data){ return data.map(applyWith(fadt)); };
  adt.compose = function() {
    var i, a = arguments, f, fi, key, tags;
    if (a.length === 0)
      return adt();
    f = typeof a[0] === 'function'? a[0] : adt(a[0]);
    for (i = 1; i < a.length; ++i) {
      fi = typeof a[i] === 'function'? a[i] : adt(a[i]);
      f = (function(fi, f){ return function(){ return fi(f.apply(this, arguments)); }; })(fi, f);
    }
    // Get all the tags of all of the interfaces
    tags = [];
    for (i = 0; i < a.length; ++i)
      if (typeof a[i] === 'object' || isInterface(a[i]))
        for (key in a[i])
          if (key.length > 0 && key[0] !== '_')
            tags.push(key);
    // Add all evaluators to the interface
    f._eval = f;
    for (i = 0; i < tags.length; ++i)
      f[tags[i]] = (function(f, tag){ 
        return function(){ return f(construct.apply(null, [tag].concat(arguments))); };
      })(f, tags[i]);
    return f;
  };
  adt.recursive = function(f) {
    if (typeof f !== 'function')
      throw "Expected a function or ADT interface in adt.recursive"
    var self = isInterface(f)? f : adt({_: f});

    var recurse = function (data) {
        var i, results = [], subResult;
        if (!isADT(data)) {
          return self(data);
        }
        for (i = 0; i < data.length; ++i) {
          subResult = recurse(data[i]);
          //if (typeof subResult !== 'undefined')
          results.push(subResult);
        }
        // TODO: Take into account pattern matching requirements...
        return self(construct(data._tag, results));
    };
    // Assign all the methods in the interface to the recursive interface too
    // TODO: But shouldn't these methods also run recursively?
    for (var key in self)
      recurse[key] = self[key];
    return recurse;
  };
  // Create ADT's from an object's own property names (both enumerable + non-enumerable)
  adt.own = function() {
    var i, j, arg, names, key, dispatchTable = {};
    for (i = 0; i < arguments.length; ++i) {
      arg = arguments[i];
      names = Object.getOwnPropertyNames(arg);
      for (j = 0; j < names.length; ++j) {
        key = names[j];
        dispatchTable[key] = arg[key];
      }
    }
    return adt(dispatchTable);
  }
  adt.own.constructors = function(obj) {
    var i, names = [];
    for (i = 0; i < arguments.length; ++i)
      names.push(Object.getOwnPropertyNames(arguments[i]));
    return adt.apply(null, Array.prototype.concat.apply([], names));
  };

  adt.serialize = function(data){
    var 
      escapeString = function(str, escapes) {
        var 
          i, 
          result = '',
          replacement,
          escapes = escapes || {
            // Single-character escape codes (JavaScript -> Haskell)
            '\0': '\\0',    // null character
            //'\a': '\\a',  // alert            (n/a in JavaScript)
            '\b': '\\b',    // backspace
            '\f': '\\f',    // form feed
            '\n': '\\n',    // newline (line feed)
            '\r': '\\r',    // carriage return
            '\t': '\\t',    // horizontal tab
            '\v': '\\v',    // vertical tab
            '\"': '\\\"',   // double quote
            //'\&': '\\&',  // empty string     (n/a in JavaScript)
            '\'': '\\\'',   // single quote
            '\\': '\\\\'    // backslash
          };
        for (i = 0; i < str.length; ++i) {
          replacement = escapes[str[i]];
          result += (replacement == null? str[i] : replacement);
        }
        return result;
      },
      escapes = {
        '\\': '\\\\',
        '\"': '\\\"',
        '\'': '\\\'',
        '\t': '\\t',
        '\r': '\\r',
        '\n': '\\n',
        ' ': '\\ ',
        ',': '\\,',
        '(': '\\(',
        ')': '\\)',
        '[': '\\[',
        ']': '\\]',
        '{': '\\{',
        '}': '\\}'
      },
      //SerializedADT = adt('SerializedADT').SerializedADT,
      serializeTagStruct = function(tag, args) {
        var
            i,
            str = escapeString(tag, escapes),
            parens;
          for (i = 0; i < args.length; ++i) {
            parens = isADT(args[i]) && args[i].length > 0;
            str += ' ' + (parens? '(' : '') + serializeEval(args[i]) + (parens? ')' : '');
          }
          return str;
      },
      serializeBuiltinEval = adt({
        Array: function(a) { 
          var 
            i,
            str ='[';
          if (a.length > 0)
            for (i = 0;; ++i) {
              str += serializeEval(a[i]);
              if (i === a.length - 1)
                break;
              str += ',';
            }
          str += ']'; 
          return str;
        },
        Object: function(a) {
          var 
            i,
            k = Object.keys(a),
            str = '{';
          if (k.length > 0)
            for (i = 0;; ++i) {
              str += escapeString(k[i], escapes) + ' = ' + serializeEval(a[k[i]]);
              if (i === k.length - 1)
                break;
              str += ',';
            }
          str += '}';
          return str;
        }
      }),
      // TODO: shorten this by using `compose`?
      serializeEval = adt({
        String: function(a) { return this._datatype === 'ADT'? serializeTagStruct('String', arguments) : '"' + a + '"'; },
        Number: function(a) { return this._datatype === 'ADT'? serializeTagStruct('Number', arguments) : String(a); },
        Boolean: function(a) { return this._datatype === 'ADT'? serializeTagStruct('Boolean', arguments) : (a? 'True' : 'False'); },
        // TODO: what about nested records, arrays and ADT's?
        Array: function(a) { return this._datatype === 'ADT'? serializeTagStruct('Array', arguments) : serializeBuiltinEval(a); },
        Arguments: function(a) { return this._datatype === 'ADT'? serializeTagStruct('Arguments', arguments) : this([].slice.call(a, 0)); },
        // TODO: what about adt's nested inside the record...
        Object: function(a) { return this._datatype === 'ADT'? serializeTagStruct('Object', arguments) : serializeBuiltinEval(a); },
        //SerializedADT: function(a) { return '(' + a + ')'; },
        _: function() {
          if (this._datatype !== 'ADT')
            // Currently unsupported: RegExp, Null, Undefined, Math, JSON, Function, Error, Date
            throw "Unsupported JavaScript built-in type `" + this._datatype + "` in `adt.serialize`.";
          return serializeTagStruct(this._tag, arguments);
        }
      });
    return serializeEval(data);
  };
  var 
    unescapeString = function(str) {
      var
        i,
        result = '',
        escapes = {
          // Single-character escape codes (Haskell -> JavaScript)
          //'0': '\0',    // null character   (handled by numeric escape codes)
          'a': '',        // alert            (n/a in javaScript)
          'b': '\b',      // backspace
          'f': '\f',      // form feed
          'n': '\n',      // newline (line feed)
          'r': '\r',      // carriage return
          't': '\t',      // horizontal tab
          'v': '\v',      // vertical tab
          '\"': '\"',     // double quote
          '&': '',        // empty string
          '\'': '\'',     // single quote
          '\\': '\\'      // backslash
        };
        /* ASCII control code abbreviations (Haskell -> JavaScript)
        \NUL  U+0000  null character
        \SOH  U+0001  start of heading
        \STX  U+0002  start of text
        \ETX  U+0003  end of text
        \EOT  U+0004  end of transmission
        \ENQ  U+0005  enquiry
        \ACK  U+0006  acknowledge
        \BEL  U+0007  bell
        \BS U+0008  backspace
        \HT U+0009  horizontal tab
        \LF U+000A  line feed (newline)
        \VT U+000B  vertical tab
        \FF U+000C  form feed
        \CR U+000D  carriage return
        \SO U+000E  shift out
        \SI U+000F  shift in
        \DLE  U+0010  data link escape
        \DC1  U+0011  device control 1
        \DC2  U+0012  device control 2
        \DC3  U+0013  device control 3
        \DC4  U+0014  device control 4
        \NAK  U+0015  negative acknowledge
        \SYN  U+0016  synchronous idle
        \ETB  U+0017  end of transmission block
        \CAN  U+0018  cancel
        \EM U+0019  end of medium
        \SUB  U+001A  substitute
        \ESC  U+001B  escape
        \FS U+001C  file separator
        \GS U+001D  group separator
        \RS U+001E  record separator
        \US U+001F  unit separator
        \SP U+0020  space
        \DEL  U+007F  delete
        */
        /* Control-with-character escapes (Haskell -> JavaScript)
        \^@ U+0000  null character
        \^A through \^Z U+0001 through U+001A control codes
        \^[ U+001B  escape
        \^\ U+001C  file separator
        \^] U+001D  group separator
        \^^ U+001E  record separator
        \^_ U+001F  unit separator
        */
      for (i = 0; i < str.length - 1; ++i) {
        if (str[i] !== '\\')
          result += str[i];
        else {
          var 
            s = str[i + 1],
            replacement = escapes[s],
            numStr = null,
            radix = null;
          if (replacement != null) {
            result += replacement;
            ++i;
            continue;
          }
          // Parse numeric escapes
          if (s >= '0' && s <= '9') {
            numStr = (/[0-9]*/).exec(str.slice(i + 1))[0];
            radix = 10; 
          } else if (s == 'x') {
            numStr = (/[0-9a-f]*/i).exec(str.slice(i + 2))[0];
            radix = 16;
          } else if (s == 'o') {
            numStr = (/[0-7]*/).exec(str.slice(i + 2))[0];
            radix = 8;
          }
          if (numStr != null && numStr.length > 0) {
            var 
              num = 0,
              j;
            for (j = 0; j < numStr.length; ++j) {
              num *= radix;
              num += parseInt(numStr[j], radix);
            }
            result += String.fromCharCode(num);
            i += numStr.length + (s == 'x' || s == 'o'? 1 : 0);
            continue;
          }
          // Direct single-character escape
          result += str[i + 1];
          ++i;
        }
      }
      // Add the last character if it wasn't escaped
      return i === str.length - 1? result + str[str.length - 1] : result;
    },
    eatWhiteSpace = function(str) {
      for (var i = 0; i < str.length; ++i) {
        switch (str[i]) {
          case ' ':
          case '\n': 
          case '\r': 
          case '\t':  
            continue;
        }
        return str.slice(i);
      }
      return '';
    },

    lexString = function(str) {
      var i, searchIndex = 1;
      // pre-condition: str.length > 1
      while (true) {
        searchIndex = str.indexOf(str[0], searchIndex);
        if (searchIndex === -1)
          throw "No closing quotation mark was found for the string starting with " + str.slice(0, Math.min(5, str.length)) + "...";
        // Check if there's an odd number of escape characters before the quotation mark character
        for (i = searchIndex - 1; i >= 0; --i)
          if (str[i] !== '\\') {
            if ((searchIndex - i) & 1 === 1) // There is an even number of slashes (or none)
              return { head: str.slice(0, searchIndex + 1), tail: str.slice(searchIndex + 1) };
            else // There is an odd number of slashes, so continue searching
              break;
          }
        searchIndex += 1;
      }
    },
    lex = function(str) {
      var 
        nextWhiteSpace,
        skip = 1;
      str = eatWhiteSpace(str);
      if (str.length === 0)
        return ['','']; // empty string
      switch (str[0]) {
        case '(':
        case ')':
        case '[':
        case ']':
        case '{':
        case '}':
        case '=':
        case ',': 
          return { head: str[0], tail: str.slice(1) };
        case '\"': 
        case '\'':
          return lexString(str);
        case '\\':
          skip = 2;
      }
      for (var i = skip; i < str.length; ++i) {
        switch (str[i]) {
          case '(':
          case ')':
          case '[':
          case ']':
          case '{':
          case '}':
          case '=':
          case ',':
          case ' ':
          case '\n':
          case '\r':
          case '\t':
            return { head: str.slice(0, i), tail: str.slice(i) };
          case '\"': 
          case '\'':
            throw "Illegal quote character `" + str[i] + "` found in lexeme. Quotes should be escaped using `\\" + str[i] + "`."
          case '\\':
            if (i === str.length - 1)
              throw "Escape character `\\` found at the end of the input string, followed by nothing."
            ++i; // skip the next character
        }
      }
      return { head: str, tail: "" };
    },
    parseADTTail = function(head, input) {
      var
        tag = unescapeString(head),
        tail = input,
        args = [];
      
      while (tail.length > 0)
        switch (tail[0]) {
          // Look ahead for terminating characters
          case ')':
          case ']':
          case '}':
          case ',':
            return { result: construct(tag, args), tail: tail };
          default:
            var parseResult = parseArgument(tail);
            if (parseResult == null)
              continue;
            args.push(parseResult.result);
            tail = parseResult.tail;
        }
      return { result: construct(tag, args), tail: tail };
    },
    parseArrayTail = function(input) {
      if (input.length < 2)
        throw "No data supplied after array opening bracket `[`.";
      var 
        tail = input,
        commaCount = 0,
        array = [];
      while (tail.length > 0)
        switch (tail[0]) {
          case ')':
          case '}':
            throw "Invalid character `" + tail[0] + "` found in the data."
          case ',':
            ++commaCount;
            if (commaCount < array.length)
              array.push(undefined);
            // post-condition: array.length === commaCount
            tail = tail.slice(1);
            continue;
          case ']':
            return { result: array, tail: tail.slice(1) };
          default:
            if (commaCount < array.length)
              throw "Expected `,` separator between array elements."
            var parseResult = parse(tail);
            if (parseResult == null)
              continue;
            array.push(parseResult.result);
            tail = parseResult.tail;
        }
      throw "Could not find the closing bracket for the array `[" + input.slice(0, Math.max(input.length,4)).join('') + "...`";
      // TODO...
      //return tail;
    },
    parseRecordTail = function(input) {
      if (input.length < 2)
        throw "No data supplied after record opening curly bracket `{`.";
      var 
        tail = input,
        commaCount = 0,
        record = {},
        lastKey = null;
      while (tail.length > 0)
        switch (tail[0]) {
          case ')':
          case ']':
            throw "Invalid character `" + tail[0] + "` found in the data."
          case ',':
            ++commaCount;
            if (commaCount < record.length)
              record.push(undefined);
            // post-condition: record.length === commaCount
            tail = tail.slice(1);
            continue;
          case '}':
            return { result: record, tail: tail.slice(1) };
          default:
            if (commaCount < record.length)
              throw "Expected `,` separator between record elements."
            var parseResult = parseRecordKeyVal(tail);
            if (parseResult == null)
              continue;
            record[parseResult.result[0]] = parseResult.result[1];
            tail = parseResult.tail;
        }
      throw "Could not find the closing curly bracket for the record `{" + input.slice(0, Math.max(input.length,4)).join('') + "...`";
    },
    parseRecordKeyVal = function(input) {
      if (input.length < 3)
        throw "Expected \'key = val\' in record syntax."
      var 
        key = unescapeString(input[0]);
      if (input[1] != '=')
        throw "Expected \'key = val\' in record syntax."
      var parseResult = parse(input.slice(2));
      return { result: [key,parseResult.result], tail: parseResult.tail };
    },
    parseParensTail = function(input) {
      if (input.length < 1)
        throw "No data after opening parenthesis.";
      var head = input[0], tail = input.slice(1);
      if (head.length === 0)
        return parseParensTail(tail); // no argument (two whitespace characters next to each other causes this)
      switch (head) {
        case '(':
          throw "Invalid double opening parentheses `((` found."
        case ')':
          throw "No data supplied after opening parenthesis `(`. The unit type, (), is not supported.";
        case '[':
        case ']':
        case '{':
        case '}':
        case ',':
        case '\"':
        case '\'':
          // Note that primitives are not allowed inside `(...)`
          throw "Invalid character `" + head + "` found after opening parenthesis."
      }
      // Parse the ADT constructor and arguments
      var parseResult = parseADTTail(head, tail);
      if (parseResult.tail.length === 0 || parseResult.tail[0] !== ')')
        throw "Could not find the closing parenthesis for the data `(" + input.slice(0, Math.max(input.length,4)).join(' ') + "...`";
      return { result: parseResult.result, tail: parseResult.tail.slice(1) };
    },
    parsePrimitive = function(head, input) {
      switch (head) {
        case '(':
          return parseParensTail(input);
        case '[':
          return parseArrayTail(input);
        case '{':
          return parseRecordTail(input);
      }
      switch (head[0]) {
        case '\"':
          //pre-condition: head[head.length - 1] === '\"'
          //pre-condition: head.length > 1
          return { result: unescapeString(head.slice(1, head.length - 1)), tail: input };
        case '\'':
          //pre-condition: head[head.length - 1] === '\"'
          //pre-condition: head.length > 1
          return { result: unescapeString(head.slice(1, head.length - 1)), tail: input };
      }
      var numberCast = Number(head);
      if (!isNaN(numberCast))
        return { result: numberCast, tail: input };
      return null;
    },
    parseArgument = function(input) {
      // This is almost identical to parse, except it only allows argumentless ADT constructors
      if (input.length == 0)
        return null;
      // pre-condition: input.length > 0
      var head = input[0], tail = input.slice(1);
      if (head.length === 0)
        return parseArgument(tail); // no argument (two whitespace characters next to each other causes this)
      // Try to parse a primitive from the stream
      var parseResult = parsePrimitive(head, tail);
      if (parseResult != null)
        return parseResult;
      // The next token is not a primitive type, so it must be a constructor tag
      var tag = unescapeString(head);
      return { result: construct(tag, []), tail: tail };
    },
    parse = function(input) {
      if (input.length == 0)
        return null;
      var head = input[0], tail = input.slice(1);
      if (head.length === 0)
        return parse(tail); // no argument (two whitespace characters next to each other causes this)
      // Try to parse a primitive from the stream
      var parseResult = parsePrimitive(head, tail);
      if (parseResult != null)
        return parseResult;
      // The next token is not a primitive type, so it must be a constructor tag
      return parseADTTail(head, tail);
    };
  adt.deserialize = function(str){
    var
      lexemes = [],
      lexState = { head: '', tail: str },
      stack = [];
    while (lexState.tail.length > 0) {
      lexState = lex(lexState.tail);
      lexemes.push(lexState.head);
    }
    // Remove all empty lexemes from the start of the array
    while (lexemes.length > 0 && lexemes[0].length == 0)
      lexemes = lexemes.slice(1);
    // Test whether the list of lexemes is empty (the string was empty or whitespace only)
    if (lexemes.length == 0)
      return;
    // Allow lisp style constructors with starting and ending parentheses
    if (lexemes[0] === '(')
      if (lexemes[lexemes.length - 1] !== ')') {
        lexemesStr = lexemes.join(' ');
        throw "Optional opening parenthesis used for the data " + lexemesStr.slice(0, Math.min(10, lexemesStr.length)) + "... but could not find the closing parenthesis.";
      }
    return parse(lexemes).result;
    // post-condition: parse(lexemes) != null (because all empty lexemes at the beginning were explicitly removed)
    // post-condition: parse(lexemes).tail.length === 0
  };
//*/



/*
  var 
    lexADT()
  adt.deserialize = function(str) {
    var
      head,
      tail,
      result;
    if (lexemes.length === 0)
      return;

    head = lexemes[0];
    tail = lexemes.slice(1);
    result = deserializeWithKey(0, head, tail);
    // post-condition: result[1].length === 0
    return result[0];
  };
*/
  // Export adt to a CommonJS module if exports is available
  if (typeof(exports) !== "undefined" && exports !== null)
    module.exports = adt;
  return adt;
})();

}, "parameterize-adt.js": function(exports, require, module) {// Generated by CoffeeScript 1.4.0
var parameterize;

parameterize = (typeof adt !== "undefined" && adt !== null ? adt : require('adt.js'))('vec4', 'vec3', 'vec2', 'real', 'integer', 'natural', 'option', 'tolerance', 'range');

if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
  module.exports = parameterize;
}
}});

// Assign this library to a global variable if a global variable is defined
var parameterizeExports = this.require("parameterize-form");
parameterize.form = parameterizeExports.form;
parameterize.html = parameterizeExports.html;
// Restore the original require method
if (typeof originalRequire === 'undefined')
  delete this.require;
else
  this.require = originalRequire;
})();

